[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Data Science (2e) - Solutions to Exercises",
    "section": "",
    "text": "Welcome\nThis is the website for the work-in-progress Solutions to Exercises for the 2nd edition of “R for Data Science”."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "There are no exercises in this chapter."
  },
  {
    "objectID": "data-visualize.html#prerequisites",
    "href": "data-visualize.html#prerequisites",
    "title": "2  Data visualization",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nlibrary(palmerpenguins)"
  },
  {
    "objectID": "data-visualize.html#exercises",
    "href": "data-visualize.html#exercises",
    "title": "2  Data visualization",
    "section": "2.2.5 Exercises",
    "text": "2.2.5 Exercises\n\nThere are 344 rows and 8 columns in the penguins data frame.\nThe bill_depth_mm denotes the bill depth in millimeters.\nThere is a positive, linear, and somewhat strong association between bill depth and bill length of penguins.\n\n\nggplot(\n  data = penguins, \n  aes(x = bill_depth_mm, y = bill_length_mm)\n) + \n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nSpecies is a categorical variable and a scatterplot of a categorical variable is not that useful as it’s difficult to use it to describe the distribution of bill depth across species.\n\n\nggplot(\n  data = penguins, \n  aes(x = bill_depth_mm, y = species)\n) + \n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nNo aesthetic mappings for x and y are provided and these are required aesthetics for the point geom.\n\n\nggplot(data = penguins) + \n  geom_point()\n#&gt; Error in `geom_point()`:\n#&gt; ! Problem while setting up geom.\n#&gt; ℹ Error occurred in the 1st layer.\n#&gt; Caused by error in `compute_geom_1()`:\n#&gt; ! `geom_point()` requires the following missing aesthetics: x and y\n\n\nSetting the na.rm argument to TRUE removes the missing values without a warning. The value for this argument is FALSE by default.\n\n\nggplot(\n  data = penguins, \n  aes(x = bill_depth_mm, y = bill_length_mm)\n) + \n  geom_point(na.rm = TRUE)\n\n\n\n\n\nThe plot from the previous exercise with caption added is provided below.\n\n\nggplot(\n  data = penguins,\n  aes(x = bill_depth_mm, y = bill_length_mm)\n) +\n  geom_point(na.rm = TRUE) +\n  labs(caption = \"Data come from the palmerpenguins package.\")\n\n\n\n\n\nThe code for recreating the visualization is provided below. The bill_depth_mm variable should be mapped at the local level, only for the point geom, as it is not used for the smooth geom – the points are colored for bill depth but the smooth line is a single color.\n\n\nggplot(\n  data = penguins,\n  aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point(aes(color = bill_depth_mm)) + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nI would expect the a scatterplot of body mass vs. flipper length with points and smooth lines for each species in a different color. The plot below indeed shows this.\n\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)\n) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nThe two plots will look the same as in the first plot the aesthetic mappings are at the global level and passed down to both geoms, and in the second plot both geoms have the same aesthetic mappings, each defined at the local level.\n\n\nggplot(\n  data = penguins,\n  mapping = aes(x = flipper_length_mm, y = body_mass_g)\n) +\n  geom_point() +\n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\nggplot() +\n  geom_point(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  ) +\n  geom_smooth(\n    data = penguins,\n    mapping = aes(x = flipper_length_mm, y = body_mass_g)\n  )\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).\n#&gt; Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "data-visualize.html#exercises-1",
    "href": "data-visualize.html#exercises-1",
    "title": "2  Data visualization",
    "section": "2.4.3 Exercises",
    "text": "2.4.3 Exercises\n\nThis code makes the bars horizontal instead of vertical.\n\n\nggplot(penguins, aes(y = species)) + \n  geom_bar()\n\n\n\n\n\nIn the first plot, the borders of the bars are colored. In the second plot, the bars are filled in with colors. The fill aesthetic is more useful for changing the color of the bars.\n\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(color = \"red\")\n\n\n\n\n\nggplot(penguins, aes(x = species)) +\n  geom_bar(fill = \"red\")\n\n\n\n\n\nIt determines the number of bins (bars) in a histogram.\nBelow are histograms with three different binwidths. I think a binwidth of 0.10 shows reveals the most interesting patterns.\n\n\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.01)\n\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 0.10)\n\nggplot(diamonds, aes(x = carat)) +\n  geom_histogram(binwidth = 1)"
  },
  {
    "objectID": "data-visualize.html#exercises-2",
    "href": "data-visualize.html#exercises-2",
    "title": "2  Data visualization",
    "section": "2.5.5 Exercises",
    "text": "2.5.5 Exercises\n\n\nmanufacturer, class, fl, drv, model, and trans are all categorical variables. displ, year, cyl, cty, and hwy are all numerical variables. You can run glimpse(mpg) or ?mpg to see a list of the variables.\nThe difference is a numerical variable doesn’t work with shape aesthetic but a categorical variable does. Also, the color scale is different for numerical and categorical variables.\n\n\nggplot(\n  mpg, \n  aes(x = hwy, y = displ, color = cty)\n) + \n  geom_point()\n\nggplot(\n  mpg, \n  aes(x = hwy, y = displ, size = cty)\n) + \n  geom_point()\n\nggplot(\n  mpg, \n  aes(x = hwy, y = displ, size = cty, color = cty)\n) + \n  geom_point()\n\nggplot(\n  mpg, \n  aes(x = hwy, y = displ, size = cty, color = cty, shape = drv)\n) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSince there is no line to alter the width of, nothing happens. The code runs as though that aesthetic was not specified.\n\n\nggplot(mpg, aes(x = hwy, y = displ, linewidth = cty)) + \n  geom_point()\n\n\n\n\n\nSee below for a sample plot that maps hwy to x, yy, and color aesthetics. ggplot2 will allow you to map the same variable to multiple aesthetics, but the resulting plot is not useful.\n\n\nggplot(mpg, aes(x = hwy, y = hwy, color = hwy)) + \n  geom_point()\n\n\n\n\n\nAdelies tend to have higher bill depth while Gentoo have longer bills and Chinstrap have deeper and longer bills.\n\n\nggplot(\n  penguins,\n  aes(x = bill_depth_mm, y = bill_length_mm, color = species)\n) + \n  geom_point()\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).\n\n\n\n\n\nThe code provided in the exercise yields two separate legends because the legend for color is renamed to \"Species\" but the legend for shape is not, and is named \"species\" by default instead. To fix it, we would need to explicitly rename the shape legend as well.\n\n\nggplot(\n  data = penguins,\n  mapping = aes(\n    x = bill_length_mm, y = bill_depth_mm, \n    color = species, shape = species\n  )\n) +\n  geom_point() +\nlabs(\n  color = \"Species\",\n  shape = \"Species\"\n)\n#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`)."
  },
  {
    "objectID": "data-visualize.html#exercises-3",
    "href": "data-visualize.html#exercises-3",
    "title": "2  Data visualization",
    "section": "2.6.1 Exercises",
    "text": "2.6.1 Exercises\n\nThe second plot is saved, because ggsave() saves the last plot you made.\n\n\nggplot(mpg, aes(x = class)) +\n  geom_bar()\n\nggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\n\nggsave(\"mpg-plot.png\")\n#&gt; Saving 6 x 4 in image\n\n\n\n\n\n\n\n\nYou need to change the suffix of the file from png to pdf in the ggsave() call."
  },
  {
    "objectID": "workflow-basics.html#prerequisites",
    "href": "workflow-basics.html#prerequisites",
    "title": "\n3  Workflow: basics\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "workflow-basics.html#exercises",
    "href": "workflow-basics.html#exercises",
    "title": "\n3  Workflow: basics\n",
    "section": "3.5 Exercises",
    "text": "3.5 Exercises\n\nThe variable is called my_variable while the next line calls it my_varıable, with an an ı (i without a dot) in the variable name. Therefore the error is due to the mismatch in variable names.\nThe corrected code is provided below.\n\n\nlibrary(tidyverse)\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() +\n  geom_smooth(method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nOption + Shift + K / Alt + Shift + K pulls up keyboard shortcuts. Alternatively, you can get to the same place with Help &gt; Keyboard Shortcuts Help.\nThe my_bar_plot object is saved because that’s what was specified in the plot argument of the ggsave() call.\n\n\nmy_bar_plot &lt;- ggplot(mpg, aes(x = class)) +\n  geom_bar()\n\nmy_scatter_plot &lt;- ggplot(mpg, aes(x = cty, y = hwy)) +\n  geom_point()\n\nggsave(filename = \"mpg-plot.png\", plot = my_bar_plot)\n#&gt; Saving 6 x 4 in image"
  },
  {
    "objectID": "data-transform.html#prerequisites",
    "href": "data-transform.html#prerequisites",
    "title": "\n4  Data transformation\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(nycflights13)\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "data-transform.html#exercises",
    "href": "data-transform.html#exercises",
    "title": "\n4  Data transformation\n",
    "section": "4.2.5 Exercises",
    "text": "4.2.5 Exercises\n\nPipelines for each part are given below.\n\n\n\n\n\nflights |&gt;\n  filter(arr_delay &gt;= 120) |&gt;\n  arrange(desc(arr_delay))\n#&gt; # A tibble: 10,200 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     9      641            900      1301     1242           1530\n#&gt; 2  2013     6    15     1432           1935      1137     1607           2120\n#&gt; 3  2013     1    10     1121           1635      1126     1239           1810\n#&gt; 4  2013     9    20     1139           1845      1014     1457           2210\n#&gt; 5  2013     7    22      845           1600      1005     1044           1815\n#&gt; 6  2013     4    10     1100           1900       960     1342           2211\n#&gt; # ℹ 10,194 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n\n\nflights |&gt;\n  filter(dest %in% c(\"IAH\", \"HOU\"))\n#&gt; # A tibble: 9,313 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      623            627        -4      933            932\n#&gt; 4  2013     1     1      728            732        -4     1041           1038\n#&gt; 5  2013     1     1      739            739         0     1104           1038\n#&gt; 6  2013     1     1      908            908         0     1228           1219\n#&gt; # ℹ 9,307 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n\n\nflights |&gt;\n  filter(carrier %in% c(\"UA\", \"DL\", \"AA\"))\n#&gt; # A tibble: 139,504 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1      517            515         2      830            819\n#&gt; 2  2013     1     1      533            529         4      850            830\n#&gt; 3  2013     1     1      542            540         2      923            850\n#&gt; 4  2013     1     1      554            600        -6      812            837\n#&gt; 5  2013     1     1      554            558        -4      740            728\n#&gt; 6  2013     1     1      558            600        -2      753            745\n#&gt; # ℹ 139,498 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n\n\nflights |&gt;\n  filter(month %in% c(7, 8, 9))\n#&gt; # A tibble: 86,326 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     7     1        1           2029       212      236           2359\n#&gt; 2  2013     7     1        2           2359         3      344            344\n#&gt; 3  2013     7     1       29           2245       104      151              1\n#&gt; 4  2013     7     1       43           2130       193      322             14\n#&gt; 5  2013     7     1       44           2150       174      300            100\n#&gt; 6  2013     7     1       46           2051       235      304           2358\n#&gt; # ℹ 86,320 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\n\n\n\nflights |&gt; \n  filter(arr_delay &gt;= 120 & dep_delay &lt;= 0) |&gt; view()\n\n\n\n\n\nflights |&gt; \n  filter(dep_delay &gt;= 60 & dep_delay - arr_delay &gt; 30)\n#&gt; # A tibble: 1,844 × 19\n#&gt;    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1  2013     1     1     2205           1720       285       46           2040\n#&gt; 2  2013     1     1     2326           2130       116      131             18\n#&gt; 3  2013     1     3     1503           1221       162     1803           1555\n#&gt; 4  2013     1     3     1839           1700        99     2056           1950\n#&gt; 5  2013     1     3     1850           1745        65     2148           2120\n#&gt; 6  2013     1     3     1941           1759       102     2246           2139\n#&gt; # ℹ 1,838 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\nFlights with longest departure delays and, among those, flights that left earliest in the morning:\n\n\nflights |&gt; \n  arrange(desc(dep_delay)) |&gt; \n  arrange(sched_dep_time) |&gt;\n  relocate(dep_delay, sched_dep_time)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   dep_delay sched_dep_time  year month   day dep_time arr_time sched_arr_time\n#&gt;       &lt;dbl&gt;          &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1        NA            106  2013     7    27       NA       NA            245\n#&gt; 2       188            500  2013     4    24      808     1008            640\n#&gt; 3        61            500  2013     9    13      601      732            648\n#&gt; 4        47            500  2013     3     9      547      733            648\n#&gt; 5        44            500  2013     6     8      544      727            640\n#&gt; 6        29            500  2013     4    17      529      704            640\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\nFastest flights, measured as miles per hour:\n\n\nflights |&gt; \n  mutate(speed = distance / (air_time / 60)) |&gt;\n  arrange(desc(speed)) |&gt;\n  relocate(speed)\n#&gt; # A tibble: 336,776 × 20\n#&gt;   speed  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1  703.  2013     5    25     1709           1700         9     1923\n#&gt; 2  650.  2013     7     2     1558           1513        45     1745\n#&gt; 3  648   2013     5    13     2040           2025        15     2225\n#&gt; 4  641.  2013     3    23     1914           1910         4     2045\n#&gt; 5  591.  2013     1    12     1559           1600        -1     1849\n#&gt; 6  564   2013    11    17      650            655        -5     1059\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n\nYes, there was a flight on every day of 2013 since there are 365 distinct combinations of year, month, and day, which is equal to the number of days in the year 2013.\n\n\nflights |&gt; \n  distinct(year, month, day) |&gt;\n  nrow()\n#&gt; [1] 365\n\n\nFlights that traveled the farthest distance:\n\n\nflights |&gt; \n  arrange(desc(distance)) |&gt;\n  relocate(distance)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   distance  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1     4983  2013     1     1      857            900        -3     1516\n#&gt; 2     4983  2013     1     2      909            900         9     1525\n#&gt; 3     4983  2013     1     3      914            900        14     1504\n#&gt; 4     4983  2013     1     4      900            900         0     1516\n#&gt; 5     4983  2013     1     5      858            900        -2     1519\n#&gt; 6     4983  2013     1     6     1019            900        79     1558\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\nFlights that travelled the shortest distance\n\nflights |&gt; \n  arrange(distance) |&gt;\n  relocate(distance)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   distance  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1       17  2013     7    27       NA            106        NA       NA\n#&gt; 2       80  2013     1     3     2127           2129        -2     2222\n#&gt; 3       80  2013     1     4     1240           1200        40     1333\n#&gt; 4       80  2013     1     4     1829           1615       134     1937\n#&gt; 5       80  2013     1     4     2128           2129        -1     2218\n#&gt; 6       80  2013     1     5     1155           1200        -5     1241\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n\nThe order doesn’t matter because we filter based on a condition, not based on row number."
  },
  {
    "objectID": "data-transform.html#exercises-1",
    "href": "data-transform.html#exercises-1",
    "title": "\n4  Data transformation\n",
    "section": "4.3.5 Exercises",
    "text": "4.3.5 Exercises\n\nI would expect dep_time to be sched_dep_time + dep_delay.\n\n\nflights |&gt; \n  relocate(dep_time, sched_dep_time, dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   dep_time sched_dep_time dep_delay  year month   day arr_time sched_arr_time\n#&gt;      &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1      517            515         2  2013     1     1      830            819\n#&gt; 2      533            529         4  2013     1     1      850            830\n#&gt; 3      542            540         2  2013     1     1      923            850\n#&gt; 4      544            545        -1  2013     1     1     1004           1022\n#&gt; 5      554            600        -6  2013     1     1      812            837\n#&gt; 6      554            558        -4  2013     1     1      740            728\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\n\nThe following are some of the ways these variables can be selected.\n\n\nflights |&gt; \n  select(dep_time, dep_delay, arr_time, arr_delay)\n#&gt; # A tibble: 336,776 × 4\n#&gt;   dep_time dep_delay arr_time arr_delay\n#&gt;      &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1      517         2      830        11\n#&gt; 2      533         4      850        20\n#&gt; 3      542         2      923        33\n#&gt; 4      544        -1     1004       -18\n#&gt; 5      554        -6      812       -25\n#&gt; 6      554        -4      740        12\n#&gt; # ℹ 336,770 more rows\n\nflights |&gt; \n  select(starts_with(\"dep\"), starts_with(\"arr\"))\n#&gt; # A tibble: 336,776 × 4\n#&gt;   dep_time dep_delay arr_time arr_delay\n#&gt;      &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1      517         2      830        11\n#&gt; 2      533         4      850        20\n#&gt; 3      542         2      923        33\n#&gt; 4      544        -1     1004       -18\n#&gt; 5      554        -6      812       -25\n#&gt; 6      554        -4      740        12\n#&gt; # ℹ 336,770 more rows\n\nflights |&gt;\n  select(dep_time:arr_delay, -contains(\"sched\"))\n#&gt; # A tibble: 336,776 × 4\n#&gt;   dep_time dep_delay arr_time arr_delay\n#&gt;      &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n#&gt; 1      517         2      830        11\n#&gt; 2      533         4      850        20\n#&gt; 3      542         2      923        33\n#&gt; 4      544        -1     1004       -18\n#&gt; 5      554        -6      812       -25\n#&gt; 6      554        -4      740        12\n#&gt; # ℹ 336,770 more rows\n\n\nYou get the variable just once.\n\n\nflights |&gt; \n  select(dep_time, dep_time)\n#&gt; # A tibble: 336,776 × 1\n#&gt;   dep_time\n#&gt;      &lt;int&gt;\n#&gt; 1      517\n#&gt; 2      533\n#&gt; 3      542\n#&gt; 4      544\n#&gt; 5      554\n#&gt; 6      554\n#&gt; # ℹ 336,770 more rows\n\n\nYou ask if any_of() these variables have a certain thing you are looking for.\n\n\nvariables &lt;- c(\"year\", \"month\", \"day\", \"dep_delay\", \"arr_delay\")\n\nflights |&gt; \n  select(any_of(variables))\n#&gt; # A tibble: 336,776 × 5\n#&gt;    year month   day dep_delay arr_delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1  2013     1     1         2        11\n#&gt; 2  2013     1     1         4        20\n#&gt; 3  2013     1     1         2        33\n#&gt; 4  2013     1     1        -1       -18\n#&gt; 5  2013     1     1        -6       -25\n#&gt; 6  2013     1     1        -4        12\n#&gt; # ℹ 336,770 more rows\n\n\nYes, it does surprise me since the variable names are lowercase but the string in contains() is uppercase. By default, contains() ignores case.\n\n\nflights |&gt; \n  select(contains(\"TIME\"))\n#&gt; # A tibble: 336,776 × 6\n#&gt;   dep_time sched_dep_time arr_time sched_arr_time air_time\n#&gt;      &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;dbl&gt;\n#&gt; 1      517            515      830            819      227\n#&gt; 2      533            529      850            830      227\n#&gt; 3      542            540      923            850      160\n#&gt; 4      544            545     1004           1022      183\n#&gt; 5      554            600      812            837      116\n#&gt; 6      554            558      740            728      150\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 1 more variable: time_hour &lt;dttm&gt;\n\nTo change this default behavior, set ignore.case = FALSE.\n\nflights |&gt; \n  select(contains(\"TIME\", ignore.case = FALSE))\n#&gt; # A tibble: 336,776 × 0\n\n\nBelow we rename air_time to air_time_min and move it to the beginning of the data frame.\n\n\nflights |&gt;\n  rename(air_time_min = air_time) |&gt;\n  relocate(air_time_min)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   air_time_min  year month   day dep_time sched_dep_time dep_delay arr_time\n#&gt;          &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;\n#&gt; 1          227  2013     1     1      517            515         2      830\n#&gt; 2          227  2013     1     1      533            529         4      850\n#&gt; 3          160  2013     1     1      542            540         2      923\n#&gt; 4          183  2013     1     1      544            545        -1     1004\n#&gt; 5          116  2013     1     1      554            600        -6      812\n#&gt; 6          150  2013     1     1      554            558        -4      740\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n\nThis doesn’t work because the result of the select() step is a data frame with only the tailnum variable, so it’s not possible to arrange it by another variable, arr_delay.\n\n\nflights |&gt; \n  select(tailnum) |&gt; \n  arrange(arr_delay)\n#&gt; Error in `arrange()`:\n#&gt; ℹ In argument: `..1 = arr_delay`.\n#&gt; Caused by error:\n#&gt; ! object 'arr_delay' not found"
  },
  {
    "objectID": "data-transform.html#exercises-2",
    "href": "data-transform.html#exercises-2",
    "title": "\n4  Data transformation\n",
    "section": "4.5.7 Exercises",
    "text": "4.5.7 Exercises\n\nF9 (Frontier Airlines) has the worst average delays.\n\n\nflights |&gt;\n  group_by(carrier) |&gt;\n  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt;\n  arrange(desc(avg_dep_delay))\n#&gt; # A tibble: 16 × 2\n#&gt;   carrier avg_dep_delay\n#&gt;   &lt;chr&gt;           &lt;dbl&gt;\n#&gt; 1 F9               20.2\n#&gt; 2 EV               20.0\n#&gt; 3 YV               19.0\n#&gt; 4 FL               18.7\n#&gt; 5 WN               17.7\n#&gt; 6 9E               16.7\n#&gt; # ℹ 10 more rows\n\n\nThe following are the top 5 most departure delayed flights from each destination.\n\n\nflights |&gt; \n  group_by(dest) |&gt; \n  arrange(dest, desc(dep_delay)) |&gt;\n  slice_head(n = 5) |&gt;\n  relocate(dest, dep_delay)\n#&gt; # A tibble: 517 × 19\n#&gt; # Groups:   dest [105]\n#&gt;   dest  dep_delay  year month   day dep_time sched_dep_time arr_time\n#&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;\n#&gt; 1 ABQ         142  2013    12    14     2223           2001      133\n#&gt; 2 ABQ         139  2013    12    17     2220           2001      120\n#&gt; 3 ABQ         125  2013     7    30     2212           2007       57\n#&gt; 4 ABQ         125  2013     9     2     2212           2007       48\n#&gt; 5 ABQ         119  2013     7    23     2206           2007      116\n#&gt; 6 ACK         219  2013     7    23     1139            800     1250\n#&gt; # ℹ 511 more rows\n#&gt; # ℹ 11 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, …\n\n\nOver the course of the day, hourly average departure delay increases until about 7pm, and then declines again, however doesn’t go as low as the beginning of the day.\n\n\nflights |&gt;\n  group_by(hour) |&gt;\n  summarize(avg_dep_delay = mean(dep_delay, na.rm = TRUE)) |&gt;\n  ggplot(aes(x = hour, y = avg_dep_delay)) + \n  geom_smooth()\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n#&gt; Warning: Removed 1 rows containing non-finite values (`stat_smooth()`).\n\n\n\n\n\nSupplying a negative value arranges the data frame in either ascending (with slice_min()) or descending (with slice_max()) order, but it doesn’t actually slice the data frame for the lowest/highest values of the given variable.\n\n\nflights |&gt; \n  slice_min(dep_delay, n = -5) |&gt;\n  relocate(dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n#&gt;       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1       -43  2013    12     7     2040           2123       40           2352\n#&gt; 2       -33  2013     2     3     2022           2055     2240           2338\n#&gt; 3       -32  2013    11    10     1408           1440     1549           1559\n#&gt; 4       -30  2013     1    11     1900           1930     2233           2243\n#&gt; 5       -27  2013     1    29     1703           1730     1947           1957\n#&gt; 6       -26  2013     8     9      729            755     1002            955\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nflights |&gt; \n  slice_min(dep_delay, n = 5) |&gt;\n  relocate(dep_delay)\n#&gt; # A tibble: 5 × 19\n#&gt;   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n#&gt;       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1       -43  2013    12     7     2040           2123       40           2352\n#&gt; 2       -33  2013     2     3     2022           2055     2240           2338\n#&gt; 3       -32  2013    11    10     1408           1440     1549           1559\n#&gt; 4       -30  2013     1    11     1900           1930     2233           2243\n#&gt; 5       -27  2013     1    29     1703           1730     1947           1957\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, …\n\nflights |&gt; \n  slice_max(dep_delay, n = -5) |&gt;\n  relocate(dep_delay)\n#&gt; # A tibble: 336,776 × 19\n#&gt;   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n#&gt;       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1      1301  2013     1     9      641            900     1242           1530\n#&gt; 2      1137  2013     6    15     1432           1935     1607           2120\n#&gt; 3      1126  2013     1    10     1121           1635     1239           1810\n#&gt; 4      1014  2013     9    20     1139           1845     1457           2210\n#&gt; 5      1005  2013     7    22      845           1600     1044           1815\n#&gt; 6       960  2013     4    10     1100           1900     1342           2211\n#&gt; # ℹ 336,770 more rows\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, …\n\nflights |&gt; \n  slice_max(dep_delay, n = 5) |&gt;\n  relocate(dep_delay)\n#&gt; # A tibble: 5 × 19\n#&gt;   dep_delay  year month   day dep_time sched_dep_time arr_time sched_arr_time\n#&gt;       &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;\n#&gt; 1      1301  2013     1     9      641            900     1242           1530\n#&gt; 2      1137  2013     6    15     1432           1935     1607           2120\n#&gt; 3      1126  2013     1    10     1121           1635     1239           1810\n#&gt; 4      1014  2013     9    20     1139           1845     1457           2210\n#&gt; 5      1005  2013     7    22      845           1600     1044           1815\n#&gt; # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,\n#&gt; #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, …\n\n\ncount() counts the number of observations in each group, setting the sort argument to TRUE arranges the categories in descending order of number of observations.\nFirst, let’s define the data frame df.\n\n\ndf &lt;- tibble(\n  x = 1:5,\n  y = c(\"a\", \"b\", \"a\", \"a\", \"b\"),\n  z = c(\"K\", \"K\", \"L\", \"L\", \"K\")\n)\n\n\nThe following groups df by y.\n\n\ndf |&gt;\n  group_by(y)\n#&gt; # A tibble: 5 × 3\n#&gt; # Groups:   y [2]\n#&gt;       x y     z    \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 a     K    \n#&gt; 2     2 b     K    \n#&gt; 3     3 a     L    \n#&gt; 4     4 a     L    \n#&gt; 5     5 b     K\n\n\nThe following arranges df in ascending order of the value of y.\n\n\ndf |&gt;\n  arrange(y)\n#&gt; # A tibble: 5 × 3\n#&gt;       x y     z    \n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 a     K    \n#&gt; 2     3 a     L    \n#&gt; 3     4 a     L    \n#&gt; 4     2 b     K    \n#&gt; 5     5 b     K\n\n\nThe following groups df by y and then calculates the average value of x for each group.\n\n\ndf |&gt;\n  group_by(y) |&gt;\n  summarize(mean_x = mean(x))\n#&gt; # A tibble: 2 × 2\n#&gt;   y     mean_x\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 a       2.67\n#&gt; 2 b       3.5\n\n\nThe following groups df by y and z, and then calculates the average value of x for each group combination. The resulting data frame is grouped by y.\n\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n#&gt; `summarise()` has grouped output by 'y'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 3 × 3\n#&gt; # Groups:   y [2]\n#&gt;   y     z     mean_x\n#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 a     K        1  \n#&gt; 2 a     L        3.5\n#&gt; 3 b     K        3.5\n\n\nThe following groups df by y and z, and then calculates the average value of x for each group combination. The resulting data frame is not grouped.\n\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x), .groups = \"drop\")\n#&gt; # A tibble: 3 × 3\n#&gt;   y     z     mean_x\n#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 a     K        1  \n#&gt; 2 a     L        3.5\n#&gt; 3 b     K        3.5\n\n\nEach of the following groups df by y and z, and then calculates the average value of x for each group combination. With summarize() the resulting data frame has one row per group combination while with mutate() the resulting data frame has the same number of rows as the original data frame.\n\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  summarize(mean_x = mean(x))\n#&gt; `summarise()` has grouped output by 'y'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 3 × 3\n#&gt; # Groups:   y [2]\n#&gt;   y     z     mean_x\n#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 a     K        1  \n#&gt; 2 a     L        3.5\n#&gt; 3 b     K        3.5\n\ndf |&gt;\n  group_by(y, z) |&gt;\n  mutate(mean_x = mean(x))\n#&gt; # A tibble: 5 × 4\n#&gt; # Groups:   y, z [3]\n#&gt;       x y     z     mean_x\n#&gt;   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1     1 a     K        1  \n#&gt; 2     2 b     K        3.5\n#&gt; 3     3 a     L        3.5\n#&gt; 4     4 a     L        3.5\n#&gt; 5     5 b     K        3.5"
  },
  {
    "objectID": "workflow-style.html#prerequisites",
    "href": "workflow-style.html#prerequisites",
    "title": "\n5  Workflow: code style\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nlibrary(nycflights13)"
  },
  {
    "objectID": "workflow-style.html#exercises-5.6",
    "href": "workflow-style.html#exercises-5.6",
    "title": "\n5  Workflow: code style\n",
    "section": "\n5.1 Exercises 5.6",
    "text": "5.1 Exercises 5.6\n\nRestyled pipelines are given below\n\n\nflights |&gt;\n  filter(dest == \"IAH\") |&gt;\n  group_by(year, month, day) |&gt;\n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  ) |&gt;\n  filter(n &gt; 10)\n#&gt; `summarise()` has grouped output by 'year', 'month'. You can override using\n#&gt; the `.groups` argument.\n#&gt; # A tibble: 365 × 5\n#&gt; # Groups:   year, month [12]\n#&gt;    year month   day     n delay\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1  2013     1     1    20 17.8 \n#&gt; 2  2013     1     2    20  7   \n#&gt; 3  2013     1     3    19 18.3 \n#&gt; 4  2013     1     4    20 -3.2 \n#&gt; 5  2013     1     5    13 20.2 \n#&gt; 6  2013     1     6    18  9.28\n#&gt; # ℹ 359 more rows\n\n\nflights |&gt;\n  filter(\n    carrier == \"UA\", \n    dest %in% c(\"IAH\", \"HOU\"), \n    sched_dep_time &gt; 0900, \n    sched_arr_time &lt; 2000\n  ) |&gt;\n  group_by(flight) |&gt;\n  summarize(\n    delay = mean(arr_delay, na.rm = TRUE), \n    cancelled = sum(is.na(arr_delay)), n = n()\n  ) |&gt;\n  filter(n &gt; 10)\n#&gt; # A tibble: 74 × 4\n#&gt;   flight delay cancelled     n\n#&gt;    &lt;int&gt; &lt;dbl&gt;     &lt;int&gt; &lt;int&gt;\n#&gt; 1     53 12.5          2    18\n#&gt; 2    112 14.1          0    14\n#&gt; 3    205 -1.71         0    14\n#&gt; 4    235 -5.36         0    14\n#&gt; 5    255 -9.47         0    15\n#&gt; 6    268 38.6          1    15\n#&gt; # ℹ 68 more rows"
  },
  {
    "objectID": "data-tidy.html#prerequisites",
    "href": "data-tidy.html#prerequisites",
    "title": "\n6  Data tidying\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "data-tidy.html#exercises",
    "href": "data-tidy.html#exercises",
    "title": "\n6  Data tidying\n",
    "section": "6.2.1 Exercises",
    "text": "6.2.1 Exercises\n\nIn each of table1, table2, and table3, each observation represents a country. In table1, country is the country name, year is the year of data collection, cases is the number of people with the disease in that year, and population is the number of people in each country in that year. In table2, country and year are the same as in table1, type is the type of number, and count is the number of observations (either cases or population depending on type). Finally, in table3, country and year are again the same as in table1, and rate is the rate of disease (cases divided by population).\n\nFor table2, we need to reshape the data have a column for cases and a column for population and then divide the two to calculate the rate. A possible approach is shown below.\n\ntable2 |&gt;\n  pivot_wider(\n    names_from = type,\n    values_from = count\n  ) |&gt; \n  mutate(rate = cases / population * 10000)\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67\n\nFor table3, we need to separate cases and population into their own columns and then divide them. A possible approach is shown below.\n\ntable3 |&gt;\n  separate_wider_delim(\n    cols = rate, \n    delim = \"/\", \n    names = c(\"cases\", \"population\"),\n  ) |&gt;\n  mutate(\n    cases = as.numeric(cases),\n    population = as.numeric(population),\n    rate = cases / population * 10000\n  )\n#&gt; # A tibble: 6 × 5\n#&gt;   country      year  cases population  rate\n#&gt;   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Afghanistan  1999    745   19987071 0.373\n#&gt; 2 Afghanistan  2000   2666   20595360 1.29 \n#&gt; 3 Brazil       1999  37737  172006362 2.19 \n#&gt; 4 Brazil       2000  80488  174504898 4.61 \n#&gt; 5 China        1999 212258 1272915272 1.67 \n#&gt; 6 China        2000 213766 1280428583 1.67"
  },
  {
    "objectID": "workflow-scripts.html#exercises",
    "href": "workflow-scripts.html#exercises",
    "title": "7  Workflow: scripts and projects",
    "section": "7.3 Exercises",
    "text": "7.3 Exercises\n\nIf you go to Tools &gt; Global Options &gt; Appearance you can change the theme of your RStudio.\nRStudio will warn with a caution icon (orange triangle with an exclamation point in it) if variable used in your code is not defined in your scope (i.e., your environment)."
  },
  {
    "objectID": "data-import.html#prerequisites",
    "href": "data-import.html#prerequisites",
    "title": "\n8  Data import\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "data-import.html#exercises",
    "href": "data-import.html#exercises",
    "title": "\n8  Data import\n",
    "section": "8.2.4 Exercises",
    "text": "8.2.4 Exercises\n\nFor reading a file delimited with |, use read_delim() with argument delim = \"|\".\nAll other arguments are common among the two functions.\ncol_positions is an important argument since it defines the beginning and end of columns.\nWe need to specify the quote argument.\n\n\nread_csv(\"x,y\\n1,'a,b'\", quote = \"\\'\")\n#&gt; Rows: 1 Columns: 2\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (1): y\n#&gt; dbl (1): x\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 1 × 2\n#&gt;       x y    \n#&gt;   &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 a,b\n\n\n\nProblems with each read_csv() statement is shown below:\\\n\n\nThere are only two column headers but three values in each row, so the last two get merged:\n\nread_csv(\"a,b\\n1,2,3\\n4,5,6\")\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n#&gt; Rows: 2 Columns: 2\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; dbl (1): a\n#&gt; num (1): b\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 2 × 2\n#&gt;       a     b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1    23\n#&gt; 2     4    56\n\n\n\nThere are only three column headers, first row is missing a value in the last column so gets an NA there, the second row has four values so the last two get merged:\n\nread_csv(\"a,b,c\\n1,2\\n1,2,3,4\")\n#&gt; Warning: One or more parsing issues, call `problems()` on your data frame for\n#&gt; details, e.g.:\n#&gt;   dat &lt;- vroom(...)\n#&gt;   problems(dat)\n#&gt; Rows: 2 Columns: 3\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; dbl (2): a, b\n#&gt; num (1): c\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 2 × 3\n#&gt;       a     b     c\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     2    NA\n#&gt; 2     1     2    34\n\n\n\nNo rows are read in:\n\nread_csv(\"a,b\\n\\\"1\")\n#&gt; Rows: 0 Columns: 2\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (2): a, b\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 0 × 2\n#&gt; # ℹ 2 variables: a &lt;chr&gt;, b &lt;chr&gt;\n\n\n\nEach column has a numerical and a character value, so the column type is coerced to character:\n\nread_csv(\"a,b\\n1,2\\na,b\")\n#&gt; Rows: 2 Columns: 2\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (2): a, b\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 2 × 2\n#&gt;   a     b    \n#&gt;   &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 1     2    \n#&gt; 2 a     b\n\n\n\nThe delimiter is ; but it’s not specified, therefore this is read in as a single-column data frame with a single observation:\n\nread_csv(\"a;b\\n1;3\")\n#&gt; Rows: 1 Columns: 1\n#&gt; ── Column specification ─────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (1): a;b\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n#&gt; # A tibble: 1 × 1\n#&gt;   `a;b`\n#&gt;   &lt;chr&gt;\n#&gt; 1 1;3\n\n\n\n\nThe non-syntactic names can be read in as follows.\n\n\nannoying &lt;- tibble(\n  `1` = 1:10,\n  `2` = `1` * 2 + rnorm(length(`1`))\n)\n\na. Extracting the variable called 1:\n\nannoying |&gt;\n  select(`1`)\n#&gt; # A tibble: 10 × 1\n#&gt;     `1`\n#&gt;   &lt;int&gt;\n#&gt; 1     1\n#&gt; 2     2\n#&gt; 3     3\n#&gt; 4     4\n#&gt; 5     5\n#&gt; 6     6\n#&gt; # ℹ 4 more rows\n\nb. Plotting a scatterplot of 1 vs. 2:\n\nggplot(annoying, aes(x = `2`, y = `1`)) +\n  geom_point()\n\n\n\n\nc. Creating a new column called 3, which is 2 divided by 1:\n\nannoying |&gt;\n  mutate(`3` = `2` / `1`)\n#&gt; # A tibble: 10 × 3\n#&gt;     `1`    `2`   `3`\n#&gt;   &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1  0.600 0.600\n#&gt; 2     2  4.26  2.13 \n#&gt; 3     3  3.56  1.19 \n#&gt; 4     4  7.99  2.00 \n#&gt; 5     5 10.6   2.12 \n#&gt; 6     6 13.1   2.19 \n#&gt; # ℹ 4 more rows\n\nd. Renaming the columns to one, two, and three:\n\nannoying |&gt;\n  mutate(`3` = `2` / `1`) |&gt;\n  rename(\n    \"one\" = `1`,\n    \"two\" = `2`,\n    \"three\" = `3`\n  )\n#&gt; # A tibble: 10 × 3\n#&gt;     one    two three\n#&gt;   &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1  0.600 0.600\n#&gt; 2     2  4.26  2.13 \n#&gt; 3     3  3.56  1.19 \n#&gt; 4     4  7.99  2.00 \n#&gt; 5     5 10.6   2.12 \n#&gt; 6     6 13.1   2.19 \n#&gt; # ℹ 4 more rows"
  },
  {
    "objectID": "workflow-help.html",
    "href": "workflow-help.html",
    "title": "9  Workflow: getting help",
    "section": "",
    "text": "There are no exercises in this chapter."
  },
  {
    "objectID": "layers.html#prerequisites",
    "href": "layers.html#prerequisites",
    "title": "\n10  Layers\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors"
  },
  {
    "objectID": "layers.html#exercises",
    "href": "layers.html#exercises",
    "title": "\n10  Layers\n",
    "section": "10.2.1 Exercises",
    "text": "10.2.1 Exercises\n\nBelow is a scatterplot of hwy vs. displ where the points are pink filled in triangles.\n\n\nggplot(mpg, aes(x = hwy, y = displ)) +\n  geom_point(color = \"pink\", shape = \"triangle\")\n\n\n\n\n\nColor should be set outside of the aesthetic mapping.\n\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"blue\")\n\n\n\n\n\nStroke controls the size of the edge/border of the points for shapes 21-24 (filled circle, square, triangle, and diamond).\nIt creates a logical variable with values TRUE and FALSE for cars with displacement values below and above 5. In general, mapping an aesthetic to something other than a variable first evaluates that expression then maps the aesthetic to the outcome.\n\n\nggplot(mpg, aes(x = hwy, y = displ, color = displ &lt; 5)) + \n  geom_point()"
  },
  {
    "objectID": "layers.html#exercises-1",
    "href": "layers.html#exercises-1",
    "title": "\n10  Layers\n",
    "section": "10.3.1 Exercises",
    "text": "10.3.1 Exercises\n\nFor a line chart you can use geom_path() or geom_line(). For a boxplot you can use geom_boxplot(). For a histogram, geom_histogram(). For an area chart, geom_area().\n\nIt removes the legend for the geom it’s specified in, in this case it removes the legend for the smooth lines that are colored based on drv.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_smooth(aes(color = drv), show.legend = FALSE)\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\nIt displays the confidence interval around the smooth lin. You can remove this with se = FALSE.\n\nThe code for each of the plots is given below.\n\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_smooth(aes(group = drv), se = FALSE) +\n  geom_point()\nggplot(mpg, aes(x = displ, y = hwy, color = drv)) + \n  geom_point() + \n  geom_smooth(se = FALSE)\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = drv)) + \n  geom_smooth(se = FALSE)\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(aes(color = drv)) +\n  geom_smooth(aes(linetype = drv), se = FALSE)\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(size = 4, color = \"white\") + \n  geom_point(aes(color = drv))"
  },
  {
    "objectID": "layers.html#exercises-2",
    "href": "layers.html#exercises-2",
    "title": "\n10  Layers\n",
    "section": "10.4.1 Exercises",
    "text": "10.4.1 Exercises\n\n\nFaceting by a continuous variable results in one facet per each unique value of the continuous variable. We can see this in the scatterplot below of cyl vs. drv, faceted by hwy.\n\nggplot(mpg, aes(x = drv, y = cyl)) + \n  geom_point() +\n  facet_wrap(~hwy)\n\n\n\n\n\n\nThere are no cars with front-wheel drive and 5 cylinders, for example. Therefore the facet corresponding to that combination is empty. In general, empty facets mean no observations fall in that category.\n\nggplot(mpg) + \n  geom_point(aes(x = drv, y = cyl)) +\n  facet_grid(drv ~ cyl)\n\n\n\n\n\n\nIn the first plot, with facet_grid(drv ~ .), the period means “don’t facet across columns”. In the second plot, with facet_grid(. ~ drv), the period means “don’t facet across rows”. In general, the period means “keep everything together”.\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n\n\n\n\n\n\n\n\n\nThe advantages of faceting is seeing each class of car separately, without any overplotting. The disadvantage is not being able to compare the classes to each other as easily when they’re in separate plots. Additionally, color can be helpful for easily telling classes apart. Using both can be helpful, but doesn’t mitigate the issue of easy comparison across classes. If we were interested in a specific class, e.g. compact cars, it would be useful to highlight that group only with an additional layer as shown in the last plot below.\n\n# facet\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_wrap(~ class, nrow = 2)\n\n# color\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy, color = class))\n\n# both\nggplot(mpg) + \n  geom_point(\n    aes(x = displ, y = hwy, color = class), \n    show.legend = FALSE) + \n  facet_wrap(~ class, nrow = 2)\n\n# highlighting\nggplot(mpg, aes(x = displ, y = hwy)) + \n  geom_point(color = \"gray\") +\n  geom_point(\n    data = mpg |&gt; filter(class == \"compact\"),\n    color = \"pink\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nnrow controls the number panels and ncol controls the number of columns the panels should be arranged in. facet_grid() does not have these arguments because the number of rows and columns are determined by the number of levels of the two categorical variables facet_grid() plots. dir controls the whether the panels should be arranged horizontally or vertically.\n\nThe first plot makes it easier to compare engine size (displ) across cars with different drive trains because the axis that plots displ is shared across the panels. What this says is that if the goal is to make comparisons based on a given variable, that variable should be placed on the shared axis.\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) + \n  facet_grid(. ~ drv)\n\n\n\n\n\n\n\n\n\nFacet grid chose to use rows instead of columns in the first code.\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(mpg) + \n  geom_point(aes(x = displ, y = hwy)) +\n  facet_wrap(~drv, nrow = 3)"
  },
  {
    "objectID": "layers.html#exercises-3",
    "href": "layers.html#exercises-3",
    "title": "\n10  Layers\n",
    "section": "10.5.1 Exercises",
    "text": "10.5.1 Exercises\n\n\nThe default geom of stat summary is geom_pointrange(). The plot from the book can be recreated as follows.\n\ndiamonds |&gt;\n  group_by(cut) |&gt;\n  summarize(\n    lower = min(depth),\n    upper = max(depth),\n    midpoint = median(depth)\n  ) |&gt;\n  ggplot(aes(x = cut, y = midpoint)) +\n  geom_pointrange(aes(ymin = lower, ymax = upper))\n\n\n\n\n\ngeom_col() plots the heights of the bars to represent values in the data, while geom_bar() first calculates the heights from data and then plots them. geom_col() can be used to make a bar plot from a data frame that represents a frequency table, while geom_bar() can be used to make a bar plot from a data frame where each row is an observation.\n\nGeoms and stats that are almost always used in concert are listed below:\n\n\ngeom\nstat\n\n\n\ngeom_bar()\nstat_count()\n\n\ngeom_bin2d()\nstat_bin_2d()\n\n\ngeom_boxplot()\nstat_boxplot()\n\n\ngeom_contour_filled()\nstat_contour_filled()\n\n\ngeom_contour()\nstat_contour()\n\n\ngeom_count()\nstat_sum()\n\n\ngeom_density_2d()\nstat_density_2d()\n\n\ngeom_density()\nstat_density()\n\n\ngeom_dotplot()\nstat_bindot()\n\n\ngeom_function()\nstat_function()\n\n\ngeom_sf()\nstat_sf()\n\n\ngeom_sf()\nstat_sf()\n\n\ngeom_smooth()\nstat_smooth()\n\n\ngeom_violin()\nstat_ydensity()\n\n\ngeom_hex()\nstat_bin_hex()\n\n\ngeom_qq_line()\nstat_qq_line()\n\n\ngeom_qq()\nstat_qq()\n\n\ngeom_quantile()\nstat_quantile()\n\n\n\n\n\nstat_smooth() computes the following variables:\n\n\ny or x: Predicted value\n\nymin or xmin: Lower pointwise confidence interval around the mean\n\nymax or xmax: Upper pointwise confidence interval around the mean\n\nse: Standard error\n\n\n\nIn the first pair of plots, we see that setting group = 1 results in the marginal proportions of cuts being plotted. In the second pair of plots, setting group = color results in the proportions of colors within each cut being plotted.\n\n# one variable\nggplot(diamonds, aes(x = cut, y = after_stat(prop))) + \n  geom_bar()\nggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + \n  geom_bar()\n\n# two variables\nggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop))) + \n  geom_bar()\nggplot(diamonds, aes(x = cut, fill = color, y = after_stat(prop), group = color)) + \n  geom_bar()"
  },
  {
    "objectID": "layers.html#exercises-4",
    "href": "layers.html#exercises-4",
    "title": "\n10  Layers\n",
    "section": "10.6.1 Exercises",
    "text": "10.6.1 Exercises\n\n\nThe mpg dataset has 234 observations, however the plot shows fewer observations than that. This is due to overplotting; many cars have the same city and highway mileage. This can be addressed by jittering the points.\n\nggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_point()\nggplot(mpg, aes(x = cty, y = hwy)) + \n  geom_jitter()\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe two plots are identical.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point()\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(position = \"identity\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe width and height parameters control the amount of horizontal and vertical displacement, recpectively. Higher values mean more displacement. In the plot below you can see the non-jittered points in gray and the jittered points in black.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"gray\") +\n  geom_jitter(height = 1, width = 1)\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"gray\") +\n  geom_jitter(height = 1, width = 5)\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_point(color = \"gray\") +\n  geom_jitter(height = 5, width = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_jitter() adds random noise to the location of the points to avoid overplotting. geom_count() sizes the points based on the number of observations at a given location.\n\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_jitter()\nggplot(mpg, aes(x = displ, y = hwy)) +\n  geom_count()\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe default is position for geom_boxplot() is \"dodge2\".\n\nggplot(mpg, aes(x = cty, y = displ)) +\n  geom_boxplot()\n#&gt; Warning: Continuous x aesthetic\n#&gt; ℹ did you forget `aes(group = ...)`?\nggplot(mpg, aes(x = cty, y = displ)) +\n  geom_boxplot(position = \"dodge2\")\n#&gt; Warning: Continuous x aesthetic\n#&gt; ℹ did you forget `aes(group = ...)`?"
  },
  {
    "objectID": "layers.html#exercises-5",
    "href": "layers.html#exercises-5",
    "title": "\n10  Layers\n",
    "section": "10.7.1 Exercises",
    "text": "10.7.1 Exercises\n\n\nWe can turn a stacked bar chart into a pie chart by adding a coord_polar() layer.\n\nggplot(diamonds, aes(x = \"\", fill = cut)) +\n  geom_bar()\n\nggplot(diamonds, aes(x = \"\", fill = cut)) +\n  geom_bar() + \n  coord_polar(theta = \"y\")\n\n\n\n\n\n\n\n\n\n\n\n\ncoord_map() projects the portion of the earth you’re plotting onto a flat 2D plane using a given projection. coord_quickmap() is an approximation of this projection.\n\ngeom_abline() adds a straight line at y = x, in other words, where highway mileage is equal to city mileage and coord_fixed() uses a fixed scale coordinate system where the number of units on the x and y-axes are equivalent. Since all the points are above the line, the highway mileage is always greater than city mileage for these cars.\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() + \n  geom_abline() +\n  coord_fixed()"
  },
  {
    "objectID": "EDA.html#prerequisites",
    "href": "EDA.html#prerequisites",
    "title": "\n11  Exploratory data analysis\n",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nlibrary(tidyverse)\n#&gt; ── Attaching core tidyverse packages ───────────────────── tidyverse 2.0.0 ──\n#&gt; ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#&gt; ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#&gt; ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#&gt; ✔ purrr     1.0.1     \n#&gt; ── Conflicts ─────────────────────────────────────── tidyverse_conflicts() ──\n#&gt; ✖ dplyr::filter() masks stats::filter()\n#&gt; ✖ dplyr::lag()    masks stats::lag()\n#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nlibrary(ggbeeswarm)\nlibrary(lvplot)\nlibrary(nycflights13)"
  },
  {
    "objectID": "EDA.html#exercises",
    "href": "EDA.html#exercises",
    "title": "\n11  Exploratory data analysis\n",
    "section": "11.3.3 Exercises",
    "text": "11.3.3 Exercises\n\n\nAll distributions are multimodal, right skewed, and have extreme outliers.\n\nggplot(diamonds, aes(x = x)) +\n  geom_histogram(binwidth = 0.1)\nggplot(diamonds, aes(x = y)) +\n  geom_histogram(binwidth = 0.1)\nggplot(diamonds, aes(x = z)) +\n  geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypical values for x and y are larger than z, which might suggest z is the depth, which matches up with the documentation. Typical values for x and y are very similar, but the maximum for y is much higher, therefore I would guess that y is width, since we generally expect width to be larger than length.\n\ndiamonds |&gt;\n  select(x, y, z) |&gt;\n  pivot_longer(cols = everything(), names_to = \"measurement\") |&gt;\n  group_by(measurement) |&gt;\n  summarize(\n    min = min(value),\n    mean = mean(value),\n    median = median(value),\n    sd = sd(value),\n    iqr = IQR(value),\n    max = max(value)\n  )\n#&gt; # A tibble: 3 × 7\n#&gt;   measurement   min  mean median    sd   iqr   max\n#&gt;   &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 x               0  5.73   5.7  1.12   1.83  10.7\n#&gt; 2 y               0  5.73   5.71 1.14   1.82  58.9\n#&gt; 3 z               0  3.54   3.53 0.706  1.13  31.8\n\n\n\nThe distribution of price is right skewed with a median of $2,401. There is a gap in the distribution with very few diamonds around $1,500, which is curious – I can’t think of a specific reason why that would be the case.\n\nggplot(diamonds, aes(x = price)) + \n  geom_histogram(binwidth = 100) +\n  scale_x_continuous(breaks = seq(0, 20000, 2000))\n\n\n\n\n\ndiamonds |&gt;\n  summarize(\n    min = min(price),\n    mean = mean(price),\n    median = median(price),\n    sd = sd(price),\n    iqr = IQR(price),\n    max = max(price)\n  )\n#&gt; # A tibble: 1 × 6\n#&gt;     min  mean median    sd   iqr   max\n#&gt;   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1   326 3933.   2401 3989. 4374. 18823\n\n\n\nOnly 23 diamonds are 0.99 carats and 1,558 diamonds are 1 carat. This is likely because the market for 0.99 carat diamonds is small. If you can get a 1 carat diamond for just a little but of increase in price. We can see that the typical price for a 1 carat diamond is less than $100 more than the typical price for a 0.99 carat diamond. For that small a difference, compared to the actual price of a diamond, many people might be willing to go up to a full carat.\n\ndiamonds |&gt;\n  filter(carat %in% c(0.99, 1)) |&gt;\n  group_by(carat) |&gt;\n  summarize(\n    n = n(),\n    median_price = median(price)\n  )\n#&gt; # A tibble: 2 × 3\n#&gt;   carat     n median_price\n#&gt;   &lt;dbl&gt; &lt;int&gt;        &lt;dbl&gt;\n#&gt; 1  0.99    23         4780\n#&gt; 2  1     1558         4864\n\n\n\nSpecifying xlim() filters out any observations not in the specified range while specifying the xlim argument in coord_cartesian() zooms into the original plot without filtering.\n\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500)\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500) +\n  xlim(0, 5000)\n#&gt; Warning: Removed 14714 rows containing non-finite values (`stat_bin()`).\n#&gt; Warning: Removed 2 rows containing missing values (`geom_bar()`).\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500) +\n  coord_cartesian(xlim = c(0, 5000))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis is similar for specifying limits for y as well.\n\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500)\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500) +\n  ylim(0, 1000)\n#&gt; Warning: Removed 13 rows containing missing values (`geom_bar()`).\nggplot(diamonds, aes(x = price)) +\n  geom_histogram(binwidth = 500) +\n  coord_cartesian(ylim = c(0, 1000))\n\n\n\n\n\n\n\n\n\n\n\n\nThe plots below show a default view, a view limited with coord_cartesian(), and a view limited with xlim() and ylim(). While coord_cartesian() zooms in to the original plot, xlim() and ylim() first filter the data for cases that fill into those bounds, and then plots them.\n\nggplot(diamonds, aes(x = carat)) + \n  geom_histogram(binwidth = 0.1) +\n  labs(title = \"No limits\")\nggplot(diamonds, aes(x = carat)) + \n  geom_histogram(binwidth = 0.1) +\n  coord_cartesian(xlim = c(0, 1), ylim = c(0, 5000)) +\n  labs(title = \"coord_cartesian(xlim = c(0, 1), ylim = c(0, 5000))\")\nggplot(diamonds, aes(x = carat)) + \n  geom_histogram(binwidth = 0.1) +\n  xlim(0, 1) +\n  ylim (0, 5000) +\n  labs(title = \"xlim(0, 1) + ylim (0, 5000)\")\n#&gt; Warning: Removed 17502 rows containing non-finite values (`stat_bin()`).\n#&gt; Warning: Removed 6 rows containing missing values (`geom_bar()`)."
  },
  {
    "objectID": "EDA.html#exercises-1",
    "href": "EDA.html#exercises-1",
    "title": "\n11  Exploratory data analysis\n",
    "section": "11.4.1 Exercises",
    "text": "11.4.1 Exercises\n\n\nIn a histogram, missing values are not plotted and a warning is emitted. In a bar plot, missing values are plotted. While it’s not possible to plot a missing numeric value, it is feasible to represent a missing categorical one with “NA” or “missing” as the level.\n\ndata_frame_with_missings &lt;- tibble(\n  x = c(runif(9), NA),\n  y = c(rep(c(\"a\", \"b\", \"c\"), 3), NA)\n)\n\nggplot(data_frame_with_missings, aes(x = x)) +\n  geom_histogram()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n#&gt; Warning: Removed 1 rows containing non-finite values (`stat_bin()`).\nggplot(data_frame_with_missings, aes(x = y)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe na.rm argument removes NAs in the data before calculating these summary statistics.\n\ndata_frame_with_missings |&gt;\n  summarize(\n    x_mean = mean(x),\n    x_mean_narm = mean(x, na.rm = TRUE),\n    x_sum = sum(x),\n    x_sum_narm = sum(x, na.rm = TRUE)\n  )\n#&gt; # A tibble: 1 × 4\n#&gt;   x_mean x_mean_narm x_sum x_sum_narm\n#&gt;    &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1     NA       0.407    NA       3.67\n\n\nTO DO: Answer this question."
  },
  {
    "objectID": "EDA.html#exercises-2",
    "href": "EDA.html#exercises-2",
    "title": "\n11  Exploratory data analysis\n",
    "section": "11.5.1.1 Exercises",
    "text": "11.5.1.1 Exercises\n\n\nTO DO: Add text.\n\ncanceled_flights &lt;- flights |&gt; \n  mutate(\n    cancelled = is.na(dep_time),\n    sched_hour = sched_dep_time %/% 100,\n    sched_min = sched_dep_time %% 100,\n    sched_dep_time = sched_hour + (sched_min / 60)\n  ) \n\n\nI would say maybe clarity or just straight up price,because the lower quality diamonds correspond to people buying them who don’t really know about diamonds or don’t care about the quality,theres alot more lower quality diamonds than higher quality.\n\nIt switching the x and y its alot faster.\n\nggplot(mpg, aes(x = hwy, y = fct_reorder(class, hwy, median))) +\n  geom_boxplot() + coord_flip()\n\n\n\n\n\n\nOne problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of “outlying values”. One approach to remedy this problem is the letter value plot. Install the lvplot package, and try using geom_lv() to display the distribution of price vs. cut. What do you learn? How do you interpret the plots?\n\nggplot(diamonds,aes(x = cut,y = price)) +\n  geom_lv()\n\n\n\n\n\n\n\n\ngeom_violin shows a basic understanding of the amount of diamonds while geom_histogram shows the further outliers better and where they are and geom_freqpoly shows the count better\n\nggplot(diamonds,aes(x = price, y = clarity)) +\n  geom_violin()\n\nggplot(diamonds,aes(x = price)) +\n  geom_histogram() +\n  facet_wrap(~clarity, ncol = 1, scales = \"free_y\")\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\nggplot(diamonds,aes(x = price, color = clarity)) +\n  geom_freqpoly()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_beeswarm() makes it so you have more control over overplotting datasets, while geom_jitter to me seems like just a default that you can use on the go but if you do want more customization ggbeeswarm is better for handling overplotting."
  },
  {
    "objectID": "EDA.html#exercises-3",
    "href": "EDA.html#exercises-3",
    "title": "\n11  Exploratory data analysis\n",
    "section": "11.5.2.1 Exercises",
    "text": "11.5.2.1 Exercises\n\n\nTO DO: Add text.\n\nggplot(diamonds, aes(x = cut, y = color)) +\n  geom_count()\n\n\n\n\n\n\n\n\nTO DO: Add text.\n\ncount(diamonds,color,cut)\n#&gt; # A tibble: 35 × 3\n#&gt;   color cut           n\n#&gt;   &lt;ord&gt; &lt;ord&gt;     &lt;int&gt;\n#&gt; 1 D     Fair        163\n#&gt; 2 D     Good        662\n#&gt; 3 D     Very Good  1513\n#&gt; 4 D     Premium    1603\n#&gt; 5 D     Ideal      2834\n#&gt; 6 E     Fair        224\n#&gt; # ℹ 29 more rows\n\nggplot(diamonds,aes( x = color, fill = cut)) +\n  geom_bar(position = \"fill\")\n\n\n\n\n\n\n\n\nTO DO: Add text.\n\nflights |&gt; \n  summarise(dest,month,year) |&gt; \n  group_by(dest,month)\n#&gt; Warning: Returning more (or less) than 1 row per `summarise()` group was deprecated\n#&gt; in dplyr 1.1.0.\n#&gt; ℹ Please use `reframe()` instead.\n#&gt; ℹ When switching from `summarise()` to `reframe()`, remember that\n#&gt;   `reframe()` always returns an ungrouped data frame and adjust accordingly.\n#&gt; # A tibble: 336,776 × 3\n#&gt; # Groups:   dest, month [1,113]\n#&gt;   dest  month  year\n#&gt;   &lt;chr&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1 IAH       1  2013\n#&gt; 2 IAH       1  2013\n#&gt; 3 MIA       1  2013\n#&gt; 4 BQN       1  2013\n#&gt; 5 ATL       1  2013\n#&gt; 6 ORD       1  2013\n#&gt; # ℹ 336,770 more rows"
  },
  {
    "objectID": "EDA.html#exercises-4",
    "href": "EDA.html#exercises-4",
    "title": "\n11  Exploratory data analysis\n",
    "section": "11.5.3.1 Exercises",
    "text": "11.5.3.1 Exercises\n\n\nIf you want to use cut_width know you r datas values,if you use cut_number know your sample size.\n\nsmaller &lt;- diamonds |&gt; \n  filter(carat &lt; 3)\n\n# visualize price binning by carat, cut_width()\nggplot(smaller, aes(x = price, y = ..density..,)) +\n  geom_freqpoly(aes(color = cut_width(carat, 0.5)))\n#&gt; Warning: The dot-dot notation (`..density..`) was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `after_stat(density)` instead.\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n# visualize price binning by carat, cut_number(), 10 bins\nggplot(smaller, aes(x = price, y = ..density..,)) +\n  geom_freqpoly(aes(color = cut_number(carat, 10)))\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\nVisualize the distribution of carat, partitioned by price.\n\nggplot(diamonds, aes(x = price, y = carat)) + \n  geom_boxplot()\n#&gt; Warning: Continuous x aesthetic\n#&gt; ℹ did you forget `aes(group = ...)`?\n\n\n\n\n\n\n\n\nIts not what i expect even the large diamonds are the same price as smaller diamonds.\n\nggplot(diamonds,aes(x = carat, y = price)) +\n  geom_point()\n\n\n\n\n\n\n\n\nTO DO: Add text.\n\nggplot(diamonds,aes(x = price, color = cut, fill = cut)) +\n  geom_freqpoly()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\nggplot(diamonds,aes(x = carat, color = cut, fill = cut)) +\n  geom_freqpoly()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\nThis scatterplot shows outliers and binned plots don’t.\n\ndiamonds |&gt; \n  filter(x &gt;= 4) |&gt; \n  ggplot(aes(x = x, y = y)) +\n  geom_point() +\n  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))\n\ndiamonds |&gt; \n  filter(x &gt;= 4) |&gt; \n  ggplot(aes(x = x)) +\n  geom_histogram()\n#&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\n\nIf you want to control the width you use cut_width, if you want to choose the number of bins use cut_number.\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_number(carat, 20)))\n\nsmaller |&gt; \n  mutate(carat_group = cut_number(carat,20)) |&gt;\n  count(carat_group)\n#&gt; # A tibble: 20 × 2\n#&gt;   carat_group     n\n#&gt;   &lt;fct&gt;       &lt;int&gt;\n#&gt; 1 [0.2,0.3]    4203\n#&gt; 2 (0.3,0.31]   2249\n#&gt; 3 (0.31,0.32]  1840\n#&gt; 4 (0.32,0.35]  2766\n#&gt; 5 (0.35,0.4]   3333\n#&gt; 6 (0.4,0.42]   2088\n#&gt; # ℹ 14 more rows\n\nggplot(smaller, aes(x = carat, y = price)) + \n  geom_boxplot(aes(group = cut_width(carat, .1)))\n\nsmaller |&gt;\n  mutate(carat_group = cut_width(carat,.1)) |&gt; \n  count(carat_group)\n#&gt; # A tibble: 27 × 2\n#&gt;   carat_group     n\n#&gt;   &lt;fct&gt;       &lt;int&gt;\n#&gt; 1 [0.15,0.25]   785\n#&gt; 2 (0.25,0.35] 10273\n#&gt; 3 (0.35,0.45]  6231\n#&gt; 4 (0.45,0.55]  5417\n#&gt; 5 (0.55,0.65]  2328\n#&gt; 6 (0.65,0.75]  5249\n#&gt; # ℹ 21 more rows"
  }
]